import scala.reflect.macros.Context
import language.experimental.macros

/*
 * Example:
 * 
 * case MapExt((1, a), (2, b)) => (a, b)
 *
 * is rewritten to  
 *
 * object Test$1{
 *   val $1 = MapExt.Key(1)
 *   val $2 = MapExt.Key(2)
 * }
 * case MapExt.And(Test$1.$1(a), Test$1.$2(b)) => (a, b)
 *
 * implementation is using untyped macros http://docs.scala-lang.org/overviews/macros/untypedmacros.html
 * and quasiquotes http://docs.scala-lang.org/overviews/macros/quasiquotes.html
 *
 * see src/test/scala/MapTest.scala for example
 */
object MapExt {
  def impl(c: Context)(xs: c.Tree*) = {
    import c.universe._    
        
    val name       = c.freshName(c.enclosingImpl.name).toTermName
    val pid        = c.enclosingPackage.pid
    def fresh      = TermName(c.freshName())    
    def mk(l:Tree) = q"val ${fresh} = MapExt.Key($l)"
    
    val args = xs.toList.map{
      case q"scala.Tuple2($key, $bind)" => mk(key) -> bind
      case q"->($key, $bind)"           => mk(key) -> bind
    }
    
    val body = args.map(_._1)
    val module = q"object $name { ..$body }"
    /*
    TODO : I don't really want to 'introduceTopLevel' as that requires all keys to be referrable from top level.
    I want to introduce the $body code (preferrably without the $module) right before the match block, which would allow everything
    in scope to be usable as key-extractors.

    example:
    (1) This is what I want to do

    object X {
      val m = Map(1 -> "a", 2 -> "b")
      def x(k1:Int, k2:Int) = m match {
        case MapExt(k1 -> a, k2 -> b) => (a, b)
      }
    }

    (2) which ideally should compile to

    object X {
      val m = Map(1 -> "a", 2 -> "b")
      def x(k1:Int, k2:Int) = {
        val $1 = MapExt.Key(k1)
        val $2 = MapExt.Key(k2)
        m match {
          case MapExt(And($1(a), $2(b))) => (a, b)
        }
      }
    }

    the problem as I see it, is that this requires modifying the code surrounding
    the macro application, in addition to the code generated by the macro itself.
    Context.introduceTopLevel is sort of a solution, but could only work for values accessible
    from topLevel (current implementation only really works with literals..)
    If there was a more general 'introduce' which allowed prepending and/or appending code anywhere,
    not only at topLevel, I could navigate (hopefully) from the MapExt macro application
    point, up to the match, and prepend my MapExt.Key instances there (example code 2)
     */
    c.introduceTopLevel(pid.toString, module)
    
    val refs = args.map{ case (k, v) => 
      val ref = q"$pid.$name.${k.name}"
      Apply(ref, List(v))
    }
    
    refs.reduceLeft[Tree]{
      case (left, right) => q"MapExt.And($left, $right)"
    }    
  }
  
  def unapply(xs: _*) = macro impl
  
  case class Key[A](key:A){
    def unapply[B](map:Map[A, B]) = map.get(key)
  }
  
  object And {
    def unapply[A](a:A) = Some((a,a))
  }
}